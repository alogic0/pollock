import Control.Applicative
import Control.Lens
import Snap
import Snap.Snaplet.Heist
import Snap.Snaplet.Session
import Snap.Snaplet.Auth
import Snap.Snaplet.Auth.Backends.JsonFile
import Snap.Snaplet.Session.Backends.CookieSession
import Snap.Util.FileServe
import Heist.SpliceAPI
import Application
import Db
import qualified Heist.Interpreted as I
import qualified Data.Text as T
import qualified Data.ByteString as BS

--------------------------------------------------------------------------------    

routes :: [(BS.ByteString, Handler Pollock Pollock ())]
routes = [ ("/signup"             , with auth handlerSignup)
         , ("/login"              , with auth handlerLogin)
         , ("/logout"             , with auth handlerLogout)
         , ("/poll/new"           , with auth handlerPollNew)
         , ("/poll/new/:pollid"   , with auth handlerPollView)
         , ("/poll/delete/:pollid", with auth handlerPollDelete)
         , ("static"              , serveDirectory "static")
         , (""                    , handlerIndex)
         ]           
              
-- | The indexHandler will be invoked whenever someone 
--   accesses the root URL, "/".
handlerIndex :: Handler Pollock Pollock ()
handlerIndex = render "index"

-- Used to output an error to the user where needed.
renderError :: Show a => a -> Handler Pollock (AuthManager Pollock) ()
renderError = renderError' . show
              
renderError' :: String -> Handler Pollock (AuthManager  Pollock) ()
renderError' s = renderWithSplices "_error" $
                 "errormsg" ## I.textSplice . T.pack $ s

-- Triggers on the /signup page
-- Form is shown on GET requests, form is handled on POST requests.
-- This idea is used on every page with a form.
handlerSignup :: Handler Pollock (AuthManager Pollock) ()
handlerSignup = method GET handleForm <|> method POST handleFormSubmit
    where
        handleForm = render "signup"
        handleFormSubmit = registerUser "username" "password" >>= afterSignup

afterSignup :: Either AuthFailure AuthUser
            -> Handler Pollock (AuthManager Pollock) ()
afterSignup (Left af) = renderError af
afterSignup _         = render "_signupsuccess"

-----------------------------------------------------------------------
                        
handlerNewPoll ::
                        
-- Triggers on the /signin page
handlerLogin :: Handler Pollock (AuthManager Pollock) ()
handlerLogin = method GET handleForm <|> method POST handleFormSubmit
    where
        handleForm = render "login"
        handleFormSubmit = loginUser "username" "password" Nothing renderError (redirect "/")

-- Triggers on the /signout page
handlerLogout :: Handler Pollock (AuthManager Pollock) ()
handlerLogout = logout >> redirect "/"

-- | Build a new Pollock snaplet.
pollockInit :: SnapletInit Pollock Pollock
pollockInit = 
  makeSnaplet "pollock" 
              "Best polling system!" 
              Nothing 
  $ do
      h <- nestSnaplet "heist" heist $
             heistInit "templates"
      s <- nestSnaplet "sess"  sess  $
             initCookieSessionManager "site_key.txt" "sess" (Just 3600)
      a <- nestSnaplet "auth"  auth  $
             initJsonFileAuthManager defAuthSettings sess "users.json"
      addRoutes routes
      addAuthSplices h auth -- add <ifLoggedIn> <ifLoggedOut> tags support
      return $ Pollock { _heist = h, _sess = s, _auth = a }
             
main :: IO ()
main = do
  (_, site, _) <- runSnaplet Nothing pollockInit
  quickHttpServe site
